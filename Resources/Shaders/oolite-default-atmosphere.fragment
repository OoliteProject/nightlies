//#version 120

// No vNormal, because normal is always 0,0,1 in tangent space.
varying vec3			vEyeVector;
varying vec2			vTexCoords;
varying vec3			vLight1Vector;
varying vec3			vCoords;

varying vec3			CameraPos;

varying vec4			vColor;
varying vec3			vVertexWorld;
varying vec3			vSurfaceWorld;
varying vec3			vVertexObj;
varying vec3			eyeVector;

varying vec3			vLight1Pos;
varying vec3			vNormal;


uniform vec4  uColor;
uniform sampler2D uCloudMap;
uniform sampler2D uDiffuse;

uniform float fPlanetRadius;
uniform float fAtmosRadius;

uniform vec3 ooposition;
uniform vec4 orientation;
uniform vec3 cameraRelativePosition;
uniform vec3 Scattering;

bool IOsphereIntersect(vec3 vPos,vec3 vRay,float Radius,inout vec3 vIntersect,inout vec3 vExit,inout float Dist) {
	float Radius2= Radius*Radius;	
	float tca = dot(vPos,normalize(vRay));
	if (tca < 0.0 ) {
		return false;
	}
	//float d2 = length(ooposition - vPos ) - pow(tca,2.0);
	float d2 = length(vPos) - pow(tca,2.0);
	if (d2 > Radius2) { 
		return false;
	}


	float thc = sqrt( Radius2 - d2 );
	float t0 = tca - thc;
	float t1 = tca + thc;
	Dist = thc*2.0;
    Dist = length( t0 - t1 );
    float tnear;
    float tfar;
    if ( t0 > 0.0 ) {
        tnear = t0;	
        tfar = t1;

    } else {
        tnear = t1;
        tfar = t0;
    }
    vIntersect = vPos + tnear * vRay;
    vExit = vPos + tfar * vRay; 
	return true;	
}

void main(void) {
	vec3 vLightCol = gl_LightSource[1].diffuse.rgb;
	
	float fObjAtmosDepth =  fPlanetRadius / fAtmosRadius ;
	//float fObjAtmosMaxDist = sqrt( 1.0 - pow( ( fAtmosRadius-fPlanetRadius ) / fAtmosRadius, 2.0 )  ) ;
	//fObjAtmosMaxDist /= 3.14;
    float fObjAtmosMaxDist = sqrt( pow(fAtmosRadius,2.0) - pow(fPlanetRadius,2.0) ) * 2.0;

    vec3 AtmosHit;
	vec3 AtmosExitHit;
    vec3 SurfaceHit;
    vec3 SurfaceExitHit;
	float AtmosDist = 0.0;
	float SurfaceDist = 0.0;

    vec4 outColor = vec4(0.0);

	float EyeDist;
    vec3 MidSample;
    float height;
    outColor.rgb = vec3(0.0);        
    vec3 FarHit;
	if ( 
		IOsphereIntersect(vVertexObj , normalize(eyeVector), 1.0 ,AtmosHit,AtmosExitHit,AtmosDist) == true) {
 		FarHit = AtmosExitHit;
        EyeDist = AtmosDist / ( fObjAtmosMaxDist / fAtmosRadius );
	
    }

	if (IOsphereIntersect(vVertexObj,normalize(eyeVector), fObjAtmosDepth ,SurfaceHit,SurfaceExitHit,SurfaceDist) == true) {
	    FarHit = SurfaceHit;
    	EyeDist = ( AtmosDist - SurfaceDist );
        EyeDist /=  (fObjAtmosMaxDist / fAtmosRadius);

    }  


    //MidSample = AtmosHit + ( normalize(eyeVector) * EyeDist * 0.5);
    MidSample = vVertexObj + (normalize(eyeVector) * 0.5 * EyeDist  );    
    height =    length(MidSample) ;

    //  outColor.rgb = MidSample;
    //outColor.rgb = eyeVector/fAtmosRadius;

	//float fScatter = (AtmosDist - SurfaceDist ) / fObjAtmosMaxDist;
	float fScatter =  EyeDist;
	float fOpacity = height;
	


	vec3 Light1Obj = (gl_LightSource[1].position.xyz -ooposition ) ;
	float Occlude = dot( normalize(Light1Obj),normalize(MidSample)) ; //MidSample or vVertexOb;
    Occlude = 0.25 + smoothstep( -0.1, 0.1 ,Occlude) *0.5 ;

	float Directional = dot(normalize(Light1Obj),normalize(MidSample));
	Directional = smoothstep( 0.0, 1.0  , -Directional );
    //outColor.r = smoothstep(-1.0,1.0 , Directional) ;
     
    float finalOpacity = EyeDist * Occlude;
    //finalOpacity += length( gl_LightSource[1].ambient );

    outColor.b = fOpacity;
    //outColor.g = Occlude;
    //outColor.r = Directional;
    //outColor.rgb = vLightCol;
    
    //outColor.rgb /= finalOpacity;
    //outColor.rgb = clamp( outColor.rgb , 0.0, 1.0 );
    
    //outColor.a = finalOpacity;
    outColor.a = 1.0 ; // ;
/*
	vec3 vRayleigh = 2.0 * Scattering.rgb * fScatter  *  smoothstep(-0.25,.25, Occlude);
	vec3 ivRayleigh = 2.0 * Scattering.rgb * fScatter  *  smoothstep(.25,-0.25, Occlude);
	outColor.rgb += vRayleigh;
	vLightCol -= ivRayleigh;
	outColor.rgb += (vLightCol * fScatter * Directional );


	//vColor.a = fScatter * Directional;
	//vColor.a = fOpacity * Directional;
    outColor.r = 1.0;
	
    // Blend based on degree of scattered light AND the occlusion 
    outColor.a = fOpacity;
    outColor.a *= Directional;
	//outColor.a *= 1.0 * smoothstep(-0.25,0.05, Occlude);

 */
    

// SAMPLING
/*
	int iSamples = 5;
	float fSamples = 5.0;

	float depthScale = fOuterRadius - fInnerRadius;
	float EyeDist;
	if ( SurfaceHit == true ) {
		EyeDist = ( AtmosDist - SurfaceDist ) / 2.0;
		//EyeDist = distance(vVertexObj,Hit);
	} else {
		EyeDist = AtmosDist; 
	}
	
	vec3 dOffset = (-normalize(eyeVector)  * EyeDist ) / fSamples;

	vec3 samplePoint = vVertexObj;
	float fOcclude = 1.0;
	vec3 PlanetHit;
	float PlanetDist = 1.0;
	vec3 Light1Obj = (gl_LightSource[1].position.xyz -ooposition ) ;
	float fDensity = 0.0;
// Occlusion samples

	vec3 vScatter = vec3(0.0);

for (int i=0;i < iSamples;i++) { 

	samplePoint += dOffset;
	fDensity +=  pow( 1 -smoothstep( fInnerRadius, fOuterRadius , length(samplePoint)*fOuterRadius  ), 2.0 );
	float Occlude = dot(normalize(Light1Obj),samplePoint);
	fOcclude -= smoothstep(-0.20,0.5, Occlude)/fSamples;
	//

	vec3 vRayleigh = (  Scattering * fDensity   *  smoothstep(0,1, Occlude)  )/ fSamples;
	vec3 ivRayleigh = (  Scattering * fDensity   *  smoothstep(1,0, Occlude)  )/ fSamples;
	vScatter += vRayleigh ;	
	vLightCol -= ivRayleigh;
	// Mie 
	vScatter += ( 0.1 * vLightCol * fDensity ) / fSamples;	
	//vScatter = vLightCol;	
}	

	fDensity /= fSamples;
	outColor.a = fDensity * (1.0-fOcclude);
	//vColor.a = 1.0;
	outColor.rgb = vScatter.rgb;
	outColor.rgb /= vColor.a;
*/ 

	gl_FragColor = outColor;	
}




